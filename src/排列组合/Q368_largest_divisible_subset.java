package 排列组合;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Q368_largest_divisible_subset {
    /*
    思入: 回溯剪枝求全部组合+ 最大公约数来判断是否加入子集. 不能加就剪枝
    结果: 过到33/43个例子(607个数组)时,超时. 因为是 复杂度是2^n,太慢
     */
    private ArrayList<Integer> result = new ArrayList<>();
    private ArrayList<Integer> temp = new ArrayList<>();
    int[] nums;

    public List<Integer> largestDivisibleSubset(int[] nums) {
        Arrays.sort(nums);
        this.nums = nums;
        helper(0, -1, -1);
        return result;
    }

    private void helper(int index, long gcd, long lcm) {
        if (result.size() < temp.size()) {
            System.out.println(temp);
            result = (ArrayList<Integer>) temp.clone();
        }
        for (int i = index; i < nums.length; i++) {
            if (temp.size() == 0 || gcd % nums[i] == 0 || nums[i] % lcm == 0) {
                temp.add(nums[i]);
                helper(i + 1, temp.size() == 1 ? nums[i] : getGcd(gcd, nums[i]), temp.size() == 1 ? nums[i] : getLcm(lcm, nums[i]));
                temp.remove(temp.size() - 1);
            }
        }
    }

    private long getGcd(long a, long b) {
        if (b == 0) return a;
        else return getGcd(b, a % b);
    }

    private long getLcm(long a, long b) {
        return a * b / getGcd(a, b);
    }

    private List<Integer> largestDivisibleSubset2(int[] nums) {
        /*
        思入:一维动态规划. dp[i]表示包含该点的最长整数序列长度.
         状态转移方程:  dp[i]= max(dp[j])+1 其中num[i]%num[j]=0
         灵感来源:   从小到大排列,就不担心 a%b 还是 b%a了. 统一都是 a%b. 思想类似 最长递增子序列
         记录父子关系来减少空间优化.
         */
        List<Integer> rnt = new ArrayList<>();
        if (nums.length == 0) return rnt;
        Arrays.sort(nums);
        int[] dp = new int[nums.length], lasts = new int[nums.length];
        int maxCount = 0, result = -1;
        Arrays.fill(lasts, -1);
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] % nums[j] == 0 && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    lasts[i] = j;
                }
            }
            if (maxCount <= dp[i]) {
                result = i;
                maxCount = dp[i];
            }
        }
        //通过父子关系找到完整的子串
        rnt.add(nums[result]);
        while ((result = lasts[result]) != -1) rnt.add(nums[result]);
        return rnt;
    }

    public static void main(String[] args) {
//        int[] nums = {468, 400, 596, 994, 843, 686, 573, 435, 868, 320, 598, 237, 407, 641, 947, 463, 323, 91, 149, 755, 628, 635, 918, 413, 250, 188, 272, 997, 513, 799, 816, 264, 746, 162, 106, 783, 86, 892, 2, 929, 563, 952, 165, 970, 592, 432, 915, 905, 933, 669, 532, 567, 938, 296, 168, 125, 920, 517, 989, 718, 332, 253, 493, 710, 579, 602, 859, 164, 903, 23, 133, 494, 485, 917, 760, 741, 201, 428, 767, 365, 286, 841, 839, 802, 830, 556, 134, 434, 723, 978, 143, 673, 908, 744, 624, 766, 260, 526, 140, 371, 976, 660, 131, 716, 212, 910, 340, 627, 259, 467, 97, 417, 648, 4, 550, 81, 727, 880, 224, 751, 787, 319, 374, 553, 578, 251, 692, 322, 973, 20, 333, 103, 735, 545, 74, 874, 343, 489, 809, 906, 807, 889, 510, 464, 473, 135, 985, 377, 64, 587, 420, 385, 559, 439, 70, 14, 174, 966, 730, 247, 72, 931, 680, 232, 358, 585, 40, 141, 391, 281, 77, 96, 613, 901, 230, 949, 277, 646, 887, 696, 30, 798, 487, 451, 811, 416, 258, 607, 315, 638, 546, 898, 574, 390, 316, 570, 392, 665, 356, 644, 305, 191, 273, 988, 806, 76, 150, 817, 393, 801, 707, 614, 438, 511, 11, 542, 900, 327, 111, 643, 127, 999, 66, 725, 655, 337, 616, 845, 656, 241, 185, 461, 334, 703, 311, 785, 100, 37, 178, 429, 789, 858, 167, 422, 923, 891, 612, 267, 99, 456, 728, 142, 220, 410, 937, 254, 499, 683, 287, 10, 496, 528, 527, 771, 418, 954, 382, 276, 225, 1000, 726, 33, 79, 491, 118, 745, 844, 406, 748, 921, 794, 492, 292, 814, 208, 930, 823, 778, 702, 543, 548, 119, 395, 73, 632, 120, 105, 711, 963, 630, 145, 837, 825, 631, 317, 138, 274, 130, 697, 204, 304, 362, 981, 5, 904, 123, 752, 512, 869, 824, 341, 280, 853, 261, 349, 338, 41, 652, 256, 478, 530, 959, 838, 85, 262, 551, 65, 266, 454, 557, 961, 732, 301, 653, 154, 307, 623, 854, 960, 894, 18, 474, 951, 38, 875, 238, 523, 425, 302, 231, 233, 107, 193, 519, 408, 846, 881, 913, 504, 856, 248, 265, 640, 591, 594, 43, 852, 821, 597, 934, 866, 827, 882, 450, 995, 836, 840, 68, 695, 777, 942, 90, 436, 558, 729, 344, 447, 671, 290, 110, 600, 58, 405, 885, 619, 202, 804, 104, 498, 379, 161, 440, 820, 795, 571, 444, 394, 452, 564, 688, 182, 236, 94, 749, 234, 829, 28, 399, 625, 15, 194, 370, 121, 589, 173, 983, 860, 484, 685, 610, 376, 108, 401, 217, 404, 637, 678, 537, 16, 621, 502, 561, 55, 914, 577, 389, 446, 650, 848, 847, 521, 924, 192, 912, 943, 927, 240, 957, 342, 458, 318, 441, 965, 996, 516, 884, 791, 427, 75, 369, 936, 431, 865, 3, 184, 772, 765, 347, 112, 588, 144, 471, 769, 897, 470, 50, 98, 810, 753, 288, 228, 980, 736, 218, 200, 826, 639, 617, 907, 285, 443, 27, 547, 899, 835, 126, 462, 657, 549, 383, 886, 935, 693, 166, 246, 580, 229, 152, 867, 93, 300, 586, 719, 742, 398, 433, 636, 308, 690, 289, 734, 916, 535, 183, 928, 116, 615, 357, 651, 83, 457, 12, 53, 939, 977, 415, 361, 506, 314, 770, 792, 291, 215, 747, 851, 63, 35, 480, 351, 175, 84, 757, 396, 544, 676, 71, 328, 984, 170, 373, 270, 309, 346, 46, 7, 520, 629, 877, 310, 348, 593, 36, 423, 102, 743, 303, 412, 210, 255, 658, 654, 739, 19, 552, 975, 326, 419, 699, 815, 387, 694, 509, 534, 245, 986, 209, 862, 115, 666, 950, 486, 879, 872, 80, 199, 293, 525, 34, 179, 850, 670, 313, 397, 576, 25, 793};

//        int[] nums = {3, 2, 8, 4,1};
//        int[] nums = {4, 8, 10, 240};
        int[] nums = {2, 3, 4, 9, 8};
        Q368_largest_divisible_subset s = new Q368_largest_divisible_subset();
        System.out.println(s.largestDivisibleSubset2(nums));
    }

}
